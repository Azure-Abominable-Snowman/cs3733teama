package com.teama.mapsubsystem.pathfinding.DijkstrasFamily.AStar;

import com.teama.mapsubsystem.data.MapEdge;
import com.teama.mapsubsystem.data.MapNode;
import com.teama.mapsubsystem.pathfinding.Path;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.ArrayList;

public class BeamSearch extends AStar {

    private HashMap<String,KnownPointA> checkedPoints;
    private LimitedPriorityQueue limitedQueue;
    private MapNode start, end;

    public BeamSearch(int queueSize)
    {
        limitedQueue =new LimitedPriorityQueue(queueSize);
    }

    /**
     * This is the BeamSearch itself inhered from Astar
     * @param start the start MapNode
     * @param end the end MapNode
     * @return the path generated by BeamSearch
     */
    public Path generatePath(MapNode start, MapNode end) {
        this.start=start;
        this.end=end;
        checkedPoints= new HashMap<>();


        KnownPointA checking ; // create a temp variable to keep track of which node are we on.

        //Generate Path
        for(checking = new KnownPointA(start,null,0,calDistance(start,end));
            !checking.getNode().getId().equals(end.getId());   // reached end
            checking= limitedQueue.pop() // move forward one step
                )
        {
            putNodesIntoQueue(checking); // put adjacent node into queue.
            checkedPoints.put(checking.getNode().getId(),checking);
            if(limitedQueue.peek()==null) {
                throw new java.lang.RuntimeException("Cannot generate a route from the given start and end.");
            }
        }
        // Done generating, output the path
        // make it into the format of outputting.
        return formatOutput(collectPath(checking));
    }

    //TODO fill this function
    public Path generatePath(MapNode start, MapNode end, ArrayList<MapNode> disableNodes){
        grabDisableNodes(disableNodes);
        return null;
    }

    /**
     * Put all the nodes that are linked to checking into the queue while keep the queue within the max size.
     * @param checking is the node currently under examining.
     */
    @Override
    protected void putNodesIntoQueue (KnownPointA checking)
    {
        for(MapEdge e : checking.getEdge()) // putting the adjacentNodes into queue
        {
            MapNode nextNode= adjacentNode(e,checking.getNode());  // get the node to be calculated.

            if( !checkedPoints.containsKey(nextNode.getId())) {  // prevent from going to points already been at.
                int newPastCost = checking.getPastCost() + (int) e.getWeight();

                KnownPointA nextPoint = new KnownPointA(nextNode, checking, newPastCost,
                        newPastCost + calDistance(nextNode, end)); // Generate a new Point from checking point to add into queue.
                limitedQueue.insert(nextPoint); // add into queue
            }
        }
    }

    public int getSize() {
        return limitedQueue.getSize();
    }

    public void setSize(int size) {
        limitedQueue.setSize(size);
    }

    /**
     * simple implementation of a PriorityQueue with linked list to control the size easily.
     */
    private class LimitedPriorityQueue
    {
        private int size;
        private  LinkedList<KnownPointA> list ;

        LimitedPriorityQueue(int size)
        {
            list = new LinkedList<>();
            this.size=size;
        }

        /**
         * Put the point into proper position (using cmopareTo) and then delete the last nodes if the list get too long
         * @param point the node need to be insert into the queue.
         */
        public void insert(KnownPointA point)
        {
            int position =0;
            for (KnownPointA i : list) {
                if(i.compareTo(point)==1) break;
                ++position;
            }
            list.add(position,point);
            for(;list.size()>size;list.pollLast()); // cut the size of the list off.
        }
        public KnownPointA peek()
        {
            return list.peek();
        }

        /**
         * same as poll used in AStar, just need a different name for Intellij didn't complain
         * @return return the first node in the list.
         */
        public KnownPointA pop()
        {
            return list.pop();
        }
        public int getSize() {
            return size;
        }
        public void setSize(int size) {
            this.size = size;
        }
    }

}
